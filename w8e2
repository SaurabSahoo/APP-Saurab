#include <stdio.h>
#include <omp.h>

#define NUM_THREADS 4
omp_lock_t locks[NUM_THREADS]; // Define an array of locks, one per thread

void worker(int tid) {
    while (1) {
        int busy = 0; // Flag to indicate if thread is busy
        omp_set_lock(&locks[tid]); // Acquire lock for the current thread
        if (tid == 0) { // If master thread
            for (int i = 1; i < NUM_THREADS; ++i) {
                if (!omp_test_lock(&locks[i])) { // Check if worker thread is not busy
                    printf("Assigning work to thread %d\n", i);
                    busy = 1;
                    omp_unset_lock(&locks[i]); // Release lock for the assigned thread
                    break;
                }
            }
        } else { // If worker thread
            busy = 1; // Assume thread is busy
            printf("Thread %d is busy\n", tid);
        }
        omp_unset_lock(&locks[tid]); // Release lock for the current thread
        if (!busy) { // If thread is not busy, do some work
            printf("Thread %d is now working\n", tid);
            // Perform some work here
            break; // Break the loop after work is done
        }
        // Sleep for a while before checking again
        #pragma omp critical
        {
            printf("Thread %d is waiting...\n", tid);
        }
        #pragma omp barrier // Wait for all threads to finish checking
        #pragma omp flush // Ensure visibility of changes made by other threads
    }
}

int main() {
    omp_set_num_threads(NUM_THREADS); // Set number of threads
    for (int i = 0; i < NUM_THREADS; ++i) {
        omp_init_lock(&locks[i]); // Initialize locks for each thread
    }

    #pragma omp parallel
    {
        int tid = omp_get_thread_num(); // Get thread ID
        worker(tid); // Call worker function
    }

    for (int i = 0; i < NUM_THREADS; ++i) {
        omp_destroy_lock(&locks[i]); // Destroy locks after use
    }

    return 0;
}
